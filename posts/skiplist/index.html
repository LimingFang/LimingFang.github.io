<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="robots" content="noodp" />
    <title class="pjax-title">LevelDB学习——2、SkipList - Leo&#39;s Blog</title><meta name="Description" content=""><meta property="og:title" content="LevelDB学习——2、SkipList" />
<meta property="og:description" content="引言​ SkipList 是 Memtable 的核心存储数据结构，其负责对用户的 record 进行有序存储。SkipList 见到的只是字节流，然后利用给定的 Comparator 进行排序存储。 ​ SkipList 保证查询和" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/posts/skiplist/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-13T12:08:18+08:00" />
<meta property="article:modified_time" content="2022-03-13T12:08:18+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="LevelDB学习——2、SkipList"/>
<meta name="twitter:description" content="引言​ SkipList 是 Memtable 的核心存储数据结构，其负责对用户的 record 进行有序存储。SkipList 见到的只是字节流，然后利用给定的 Comparator 进行排序存储。 ​ SkipList 保证查询和"/>
<meta name="application-name" content="Leo&#39;s Blog">
<meta name="apple-mobile-web-app-title" content="Leo&#39;s Blog">

<meta name="theme-color" content="#f8f8f8"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="canonical" href="http://example.org/posts/skiplist/" /><link rel="prev" href="http://example.org/posts/%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/fontawesome-free/all.min.css">
        <noscript><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"></noscript><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/animate/animate.min.css">
        <noscript><link rel="stylesheet" href="/lib/animate/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "LevelDB学习——2、SkipList",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "http:\/\/example.org\/posts\/skiplist\/"
        },"genre": "posts","keywords": "LevelDB","wordcount":  2028 ,
        "url": "http:\/\/example.org\/posts\/skiplist\/","datePublished": "2022-03-13T12:08:18+08:00","dateModified": "2022-03-13T12:08:18+08:00","publisher": {
            "@type": "Organization",
            "name": "作者"},"authors": [{
                    "@type": "Person",
                    "name": "方里明"
                }],"description": ""
    }
    </script></head>

<body header-desktop="" header-mobile=""><script type="text/javascript">
        function setTheme(theme) {document.body.setAttribute('theme', theme);}
        function saveTheme(theme) {window.localStorage && localStorage.setItem('theme', theme);}
        function getMeta(metaName) {const metas = document.getElementsByTagName('meta'); for (let i = 0; i < metas.length; i++) if (metas[i].getAttribute('name') === metaName) return metas[i]; return '';}
        if (window.localStorage && localStorage.getItem('theme')) {let theme = localStorage.getItem('theme');theme === 'light' || theme === 'dark' || theme === 'black' ? setTheme(theme) : (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? setTheme('dark') : setTheme('light')); } else { if ('' === 'light' || '' === 'dark' || '' === 'black') setTheme(''), saveTheme(''); else saveTheme('auto'), window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? setTheme('dark') : setTheme('light');}
        let metaColors = {'light': '#f8f8f8','dark': '#252627','black': '#000000'}
        getMeta('theme-color').content = metaColors[document.body.getAttribute('theme')];
    </script>
    <div id="back-to-top"></div>
    <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Leo&#39;s Blog">Leo&#39;s Blog</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><span class="menu-item delimiter"></span><a href="#" onclick="return false;" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Leo&#39;s Blog">Leo&#39;s Blog</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a href="#" onclick="return false;" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
            <div class="container"><script>document.getElementsByTagName("main")[0].setAttribute("pageStyle", "normal")</script><article class="page single"><h1 class="single-title animate__animated animate__flipInX">LevelDB学习——2、SkipList</h1><div class="post-meta">
            <div class="post-meta-line">
                <span class="post-author"><span class='author'><i class="author fas fa-user-circle fa-fw"></i><span class='screen-reader-text'>  </span><a href='http://example.org/authors/leo'>方里明</a></span>
                </span>&nbsp;<span class="post-category">收录于 </span>&nbsp;<span class="post-category">类别 <a href="/categories/leveldb%E5%AD%A6%E4%B9%A0/"><i class="far fa-folder fa-fw"></i>LevelDB学习</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2022-03-13">2022-03-13</time>&nbsp;<i class="far fa-edit fa-fw"></i>&nbsp;<time datetime="2022-03-13">2022-03-13</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 2028 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 5 分钟&nbsp;</div>
        </div><div class="content" id="content"><h1 id="引言" class="headerLink">
    <a href="#%e5%bc%95%e8%a8%80" class="header-mark"></a>引言</h1><p>​		 SkipList 是 Memtable 的核心存储数据结构，其负责对用户的 record 进行有序存储。SkipList 见到的只是字节流，然后利用给定的 Comparator 进行排序存储。</p>
<p>​		SkipList 保证查询和插入的时间复杂度为O（LogN）</p>
<p>​		leveldb 中的 skiplist 对并发进行额外控制，支持一写多读，即只有多写需要上层并发控制。</p>
<h1 id="skiplist-原理" class="headerLink">
    <a href="#skiplist-%e5%8e%9f%e7%90%86" class="header-mark"></a>SkipList 原理</h1><p>​		SkipList 是对单链表的拓展。链表的节点插入和删除本身是O（1）的，慢的是查询到相应的节点。单链表没法使用二分搜索，必须O（N）遍历一遍。因此一个很自然的思路是每个节点多存一些信息，以此加快遍历的速度，比如每次允许每次往后跳2个，或者4个节点，以此类推&hellip;. 因此<code>SkipList</code> 的每个节点具有 height 属性，一次性保存了多个后驱节点指，在自上而下查询的时候，刚开始能每次 step 非常远，达到加速查询的效果。举个例子，我们在查询 25 这个节点时只需要跳两次，而单链表则需要9次左右。每个节点的 height 是服从几何分布的，一般常见的是 p = 3/4 的几何分布：3/4 的概率高度为1，3/16 的概率高度为2，以此类推。最终数学上能证明 <code>SkipList</code> 的查询和插入的时间复杂度是 O(LogN)（至于为什么我们不用太关心）。此外，p = 3/4 的时候，每个节点的期望高度是 4/3，即平均只多耗费了33%的空间。</p>
<p><img
        class="lazyload"
        data-src="https://github.com/LimingFang/LimingFang.github.io/raw/master/picture/leveldb/skiplist.png"
        data-srcset="https://github.com/LimingFang/LimingFang.github.io/raw/master/picture/leveldb/skiplist.png, https://github.com/LimingFang/LimingFang.github.io/raw/master/picture/leveldb/skiplist.png 1.5x, https://github.com/LimingFang/LimingFang.github.io/raw/master/picture/leveldb/skiplist.png 2x"
        data-sizes="auto"
        alt="https://github.com/LimingFang/LimingFang.github.io/raw/master/picture/leveldb/skiplist.png"
        title="skiplist"></p>
<p>​		从结构上说，<code>SkipList</code> 保存了 dummy header，这个在单链表中也经常使用，方便头节点的操作。在 <code>SkipList</code> 中还体现在 header 的高度是最大的，保证始终是自顶向下搜索。<code>Node</code> 中 next 数组保存了当前节点每一层的后驱节点，采用了弹性数组，不过为了方便也可以每个 <code>Node</code> 的 next 数组空间都拉满（</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">class</span> <span class="nc">SkipList</span> <span class="p">{</span>
  <span class="c1">// function
</span><span class="c1"></span>  <span class="c1">// ..other unimportant data member
</span><span class="c1"></span>  <span class="n">Node</span><span class="o">*</span> <span class="n">header_</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">max_height_</span><span class="p">;</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">kMaxHeight</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">key</span><span class="p">;</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">next</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="c1">// Or Node* next[kMaxHeight];
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div><h2 id="查询" class="headerLink">
    <a href="#%e6%9f%a5%e8%af%a2" class="header-mark"></a>查询</h2><blockquote>
<p>基本规则：每一层的最后一个 Node 在当前层的后驱节点是 nullptr，它对应的 key 是正无穷。这保证了我们一定能找到 Node A，其大于等于我们要找的 Node。尽管A 可能是 Nil Node。</p>
</blockquote>
<p>​		概括的说，查询从左上至右下，最终定位到某个 Node，这个 Node &gt;= 【我们要找的 Node】。如果相等那最好，不相等那就是不存在。</p>
<p>​		更仔细的说，假设要找 Node A。从 dummy header 的最上层开始，判断当前层的后驱节点是否小于 Node A：</p>
<ul>
<li>如果是，就继续在当前层往后走。</li>
<li>如果不是，就高度减1⃣️
<ul>
<li>如果已经到了最底层，就返回后驱节点</li>
<li>否则继续在当前层和 Node A对比。</li>
</ul>
</li>
</ul>
<p>​		举个例子，假设要查询25（上图），在返回时，会经历【header_,6,25】三个节点。</p>
<h2 id="插入" class="headerLink">
    <a href="#%e6%8f%92%e5%85%a5" class="header-mark"></a>插入</h2><p>​		单链表的插入只需记录前驱节点，<code>SkipList</code> 由于后驱节点时一个数组，因此每一层都需要记录前驱节点。</p>
<p>​		以插入18为例，每一层的前驱节点是【6，6，17，17】</p>
<h1 id="实现分析" class="headerLink">
    <a href="#%e5%ae%9e%e7%8e%b0%e5%88%86%e6%9e%90" class="header-mark"></a>实现分析</h1><p>​		从插入和查询原理可以发现，需要一个函数能定位到第一个大于等于待查询 Node 的Node，同时还要记录 path 上的前驱节点，leveldb 里是 <code>FindGreaterOrEqual</code>。同时还需要将当前节点的后驱节点与待查询的 key 比较，叫 <code>KeyIsAfterNode</code>。</p>
<p>​		同时还需要在插入时生成新的节点，且高度是随机的（几何分布）。</p>
<p>​		同时还需要设置、获取后驱节点的辅助函数。</p>
<p>​		从之前的 <code>Node</code> 可以发现，我们只需要记录 next 数组，但不需要记录当前层数，因为当访问到 <code>Node</code> 时，一定是在它高度之内的，否则根本没有指针指向它。<code>NewNode</code> 中的 <code>height</code> 参数是在申请堆内存时用到。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="nf">Insert</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">key</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">Contains</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">key</span><span class="p">);</span>

<span class="c1">// @result-&gt;key &gt;= key.
</span><span class="c1"></span><span class="n">Node</span><span class="o">*</span> <span class="nf">FindGreaterOrEqual</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">key</span><span class="p">,</span> <span class="n">Node</span><span class="o">**</span> <span class="n">prev</span><span class="p">);</span>
<span class="c1">// If true =&gt; key &gt; node-&gt;key.
</span><span class="c1"></span><span class="kt">bool</span> <span class="nf">KeyIsAfterNode</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">key</span><span class="p">,</span> <span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">GetRandomHeight</span><span class="p">();</span>
<span class="n">Node</span><span class="o">*</span> <span class="nf">NewNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">height</span><span class="p">);</span>
<span class="n">Node</span><span class="o">*</span> <span class="nf">Next</span><span class="p">(</span><span class="kt">int</span> <span class="n">level</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">SetNext</span><span class="p">(</span><span class="kt">int</span> <span class="n">level</span><span class="p">,</span><span class="n">Node</span><span class="o">*</span> <span class="n">next</span><span class="p">);</span>
</code></pre></div><p>​		作如下规定：最下面一层是第零层，即 <code>level = 0</code> 但是高度是1。</p>
<h2 id="keyisafternode" class="headerLink">
    <a href="#keyisafternode" class="header-mark"></a><code>KeyIsAfterNode</code></h2><p>​		如果 node 非空，则正常比较；如果 <code>node == nullptr</code> 则一定是 <code>node</code> 大。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Comparator</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">SkipList</span><span class="o">&lt;</span><span class="n">Comparator</span><span class="o">&gt;::</span><span class="n">KeyIsAfterNode</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">key</span><span class="p">,</span> <span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">!</span><span class="n">node</span> <span class="o">||</span> <span class="n">comparator_</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h2 id="findgreaterorequal" class="headerLink">
    <a href="#findgreaterorequal" class="header-mark"></a><code>FindGreaterOrEqual</code></h2><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Comparator</span><span class="o">&gt;</span>
<span class="k">typename</span> <span class="n">SkipList</span><span class="o">&lt;</span><span class="n">Comparator</span><span class="o">&gt;::</span><span class="n">Node</span><span class="o">*</span> <span class="n">SkipList</span><span class="o">&lt;</span><span class="n">Comparator</span><span class="o">&gt;::</span><span class="n">FindGreaterOrEqual</span><span class="p">(</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">key</span><span class="p">,</span> <span class="n">Node</span><span class="o">**</span> <span class="n">prev</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="n">header_</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">lev</span> <span class="o">=</span> <span class="n">max_height_</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">(</span><span class="n">lev</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">KeyIsAfterNode</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">next</span><span class="p">))</span> <span class="p">{</span>
      <span class="c1">// 当前层单链表继续操作
</span><span class="c1"></span>      <span class="n">n</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// 在当前 Node 降层
</span><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">prev</span><span class="p">[</span><span class="n">lev</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">lev</span><span class="o">--</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">lev</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">next</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="insert" class="headerLink">
    <a href="#insert" class="header-mark"></a><code>Insert</code></h2><p>​		这里指分析插入，因为链表的插入和查询代码几乎一样。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Comparator</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">SkipList</span><span class="o">&lt;</span><span class="n">Comparator</span><span class="o">&gt;::</span><span class="n">Insert</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Node</span> <span class="n">prev</span><span class="p">[</span><span class="n">kMaxHeight</span><span class="p">];</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="n">FindGreaterOrEqual</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prev</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">&amp;&amp;</span> <span class="n">comparator_</span><span class="p">(</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 重复 key 不插入
</span><span class="c1"></span>    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">GetRandomHeight</span><span class="p">();</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">new_node</span> <span class="o">=</span> <span class="n">NewNode</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
  <span class="c1">// 如果新节点超高，则超出的部分前驱节点是header（此时是nullptr）
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">max_height_</span> <span class="o">&lt;</span> <span class="n">h</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">max_height_</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">prev</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">header_</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">max_height_</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// 每个前驱节点新的后驱节点需要更新
</span><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">h</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">SetNext</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">prev</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Next</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
    <span class="n">prev</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">SetNext</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">new_node</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h1 id="iterator" class="headerLink">
    <a href="#iterator" class="header-mark"></a>Iterator</h1><p>​		上层 <code>Memtable</code>  需要提供顺序访问 record 的能力，即需要实现配套的迭代器，而迭代器的各种功能最终都是需要其底层数据容器来提供的。因此 <code>SkipList</code> 需要实现配套的迭代器（自身必然要额外实现一些辅助函数）</p>
<h2 id="设计" class="headerLink">
    <a href="#%e8%ae%be%e8%ae%a1" class="header-mark"></a>设计</h2><p>​		首先定义虚基类 <code>Iterator</code>。对于迭代器而言，抽象出的操作包括：判定当前位置是否合法、前驱/后驱、返回当前位置的值。额外的操作是重定位到最开头或者最后。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">class</span> <span class="nc">Iterator</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">Iterator</span><span class="p">();</span>
  <span class="n">Iterator</span><span class="p">(</span><span class="k">const</span> <span class="n">Iterator</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
  <span class="n">Iterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Iterator</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">Iterator</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">Valid</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Next</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="n">Slice</span> <span class="nf">Key</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="n">Slice</span> <span class="nf">Value</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">SeekToLast</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">SeekToFirst</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">SeekTo</span><span class="p">(</span><span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">slice</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div><ul>
<li>
<p><code>SeekTo</code>，这要求我们<strong>找到第一个不小于slice 的 Node</strong>，其实就是 <code>FindGreaterOrEqual</code></p>
</li>
<li>
<p><code>SeekToLast</code>：找到最后一个节点，基于 <code>SkipList::FindLast</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Comparator</span><span class="o">&gt;</span>
<span class="k">typename</span> <span class="n">SkipList</span><span class="o">&lt;</span><span class="n">Comparator</span><span class="o">&gt;::</span><span class="n">Node</span><span class="o">*</span> <span class="n">SkipList</span><span class="o">&lt;</span><span class="n">Comparator</span><span class="o">&gt;::</span><span class="n">FindLast</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">header_</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">header_</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="n">header_</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">max_height_</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">h</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">h</span><span class="o">--</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></li>
</ul>
<p>​		其他几个都比较简单，略过</p>
</div>

        <div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2022-03-13</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/leveldb/">LevelDB</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="prev" rel="prev" title="rCore学习——2、批处理系统（三叶虫）"><i class="fas fa-angle-left fa-fw"></i>rCore学习——2、批处理系统（三叶虫）</a></div>
</div>
</article></div>
        </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">
                    由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.92.2">Hugo</a> 强力驱动&nbsp;|&nbsp;主题 - <a href="https://github.com/HEIGE-PCloud/DoIt" target="_blank" rel="noopener noreffer" title="DoIt 0.2.13"><i class="far fa-edit fa-fw"></i> DoIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank" rel="noopener noreferrer"></a></span></div>
            <div class="footer-line"></div>
            <div class="footer-line">
            </div>
        </div></footer></div>

    <div id="fixed-buttons"><a href="#back-to-top" id="back-to-top-button" class="fixed-button" title="回到顶部">
            <i class="fas fa-arrow-up fa-fw"></i>
        </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
            <i class="fas fa-comment fa-fw"></i>
        </a>
    </div><div class="assets"><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/topbar/topbar.min.js"></script><script type="text/javascript" src="/lib/pjax/pjax.min.js"></script><script type="text/javascript" src="/js/theme.min.js" defer></script></div>

<div class="pjax-assets"><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{}};</script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script></div>
</body>

</html>